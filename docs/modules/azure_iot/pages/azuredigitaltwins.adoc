= Azure Digital Twins
:title: Azure Digital Twins
:navtitle: Azure Digital Twins
:source-highlighter: highlight.js
:highlightjs-languages: shell, console, json, sql, csharp
:toc:

== Environment and Service Goals

Azure Digital Twins is a platform as a service (PaaS) offering that enables the creation of knowledge graphs. 

The knowledge graph is based on interconnected digital entities that combine to represent a larger, interactive environment.

The size and complexity of the environment is dependent upon your business needs, and could represent things like buildings, factories, farms, energy networks, railways, stadiums, and more—even entire cities.

[NOTE]
====
* Digital Twins (in Azure Digital Twins) and Device Twins (in IoT Hub) may sound similar, but they are two different things.
* IoT Hub device twins often focus on describing the aspects and capabilities of a device itself.
* Digital Twins are more conceptual representations that can store user-defined insights about a digital entity or many related entities.
* Entities that could be representing a device or many related devices.
* It is also worth noting that IoT Hub device twins can be connected to Azure Digital Twins (the service) as part of an end-to-end solution that represents devices across services.
====

=== Simple Azure Digital Twins Environment Scenario

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-components-azure-digital-twins-solution/media/m11-l02-simple-twins-environment-fb572ff0.png[]

Consider the above example where we define an environment that represents a small building (the Azure Digital Twins graph shown above).

In this example, our building is composed of digital twins that represent the floors of the building, and the rooms on each floor.

The lines on the Graph that connect a Floor to a Room are called relationships.

Relationships help to define how our digital twins are related to one another.

In this case, the relationship tells us that a floor “contains” rooms.


== Services and Data Workflows that form an Azure Digital Twins Solution

Azure Digital Twins is typically used together with other services to create flexible, connected solutions that use your data in various workflows.

* Using Event Routes, Azure Digital Twins can receive data from upstream services such as IoT Hub or Logic Apps, which are used to deliver telemetry and notifications.
* Azure Digital Twins can also route data to downstream services, such as Azure Maps and Time Series Insights, for storage, workflow integration, analytics, and more.

=== Data Ingress

Azure Digital Twins can be driven with data and events from any service—IoT Hub, Logic Apps, your own custom service, and more.

This capability allows you to collect telemetry from physical devices in your environment, and process this data using the Azure Digital Twins graph in the cloud.

Instead of having a built-in IoT Hub behind the scenes, Azure Digital Twins allows you to "bring your own" IoT Hub to use with the service.

You can use an existing IoT Hub you currently have in production, or deploy a new one to be used for this purpose.

This capability gives you full access to all of the device management capabilities of IoT Hub.

To ingest data from any source into Azure Digital Twins, use an Azure function.

=== Data Egress

Azure Digital Twins can send data to connected endpoints. Supported endpoints can be:

* Event Hubs
* Event Grids
* Service Bus

Endpoints are attached to Azure Digital Twins using management APIs or the Azure portal.

There are many other services where you may want to ultimately direct your data, such as Azure Storage, Azure Maps, or Time Series Insights.

To send your data to services like these, attach the destination service to an endpoint.

For example, if you are also using Azure Maps and want to correlate location with your Azure Digital Twins twin graph, you can use Azure Functions with Event Grid to establish communication between all the services in your deployment.

=== Azure Digital Twins in a solution context

Azure Digital Twins is commonly used in combination with other Azure services as part of a larger IoT solution.

A complete solution using Azure Digital Twins may contain the following parts:

* The Azure Digital Twins service instance. The Azure Digital Twins service stores your twin graph with its state and orchestrates event processing.
* One or more client apps that may be used when building the Azure Digital Twins solution (to create digital entities and a topology, or to extract insights from the twin graph).
* One or more external compute resources to process events generated by Azure Digital Twins, or by connected data sources such as devices. One common way to provide compute resources is via Azure Functions.
* An IoT hub to provide device management and IoT data stream capabilities.
* Downstream services to handle tasks such as workflow integration (like Logic Apps, cold storage, time series integration, or analytics).

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-components-azure-digital-twins-solution/media/m11-l02-adt-solution-services-24939866.png[]


== Azure Digital Twins Models

In an Azure Digital Twins solution, Models provide the blueprint that is used to create the digital twin entities within your Azure Digital Twins environment.

Consider this example of an Azure Digital Twins environment expressed as a graph.

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-components-azure-digital-twins-solution/media/m11-l02-simple-twins-environment-fb572ff0.png[]

The nodes that you see in this graph are the digital twin instances that were created using the corresponding Model (either a Floor or a Room model).

Models have names (such as Floor, Room, or TemperatureSensor), and contain elements such as properties, telemetry/events, and relationships that describe how the digital twin entities are related to each other within your environment.


=== Elements of a model

Azure Digital Twins models are defined using the Digital Twins Definition Language (DTDL), which is expressed using a JSON-style coding format.

Within a model definition, the top-level code item is an Interface, which encapsulates the entire model.

A DTDL model interface may contain zero, one, or many of each of the following fields:

* *Property*
** Properties are data fields that represent the state of an entity.
** Like the properties in many object-oriented programming languages.
** Properties have backing storage and can be read at any time.
* *Telemetry*
** Telemetry fields represent measurements or events, and are often used to describe device sensor readings.
** Unlike properties, telemetry is not stored on a digital twin; it is a series of time-bound data events that need to be handled as they occur.
* *Component*
** Components allow you to build your model interface as an assembly of other interfaces, if you want.
** An example of a component is a frontCamera interface (and another component interface backCamera) that are used in defining a model for a phone.
** You must first define an interface for frontCamera as though it were its own model, and then you can reference it when defining Phone.
** Use a component to describe something that is an integral part of your solution but doesn't need a separate identity, and doesn't need to be created, deleted, or rearranged in the twin graph independently.
** If you want entities to have independent existences in the twin graph, represent them as separate digital twins of different models, connected by relationships
* *Relationship*
** Relationships let you represent how a digital twin can be involved with other digital twins.
** Relationships can represent different semantic meanings, such as contains ("floor contains room"), cools ("hvac cools room"), isBilledTo ("compressor is billed to user"), etc.
** Relationships allow the solution to provide a graph of interrelated entities.

=== Differentiating between Property and Telemetry Fields

Since property and telemetry fields could both represent numeric data, it may not be obvious when or where each should be used.

Here is some more guidance on distinguishing between DTDL property and telemetry fields in Azure Digital Twins.

The difference between properties and telemetry for Azure Digital Twins models is as follows:

* *Properties*
** Properties are expected to have backing storage (a stored and accessible value).
** You can read a property at any time and retrieve its value.
** If the property is writeable, you can also assign a value to the property.
* *Telemetry*
** Telemetry is more like a stream of events; it’s a set of data messages that have short lifespans.
** If you don't monitor for a telemetry event and take actions when it happens, there is no trace of the event at a later time.
** You can't come back to it and read it later. 
*** In C# terms, telemetry is like a C# event.
*** In IoT terms, telemetry is typically a data value sent by a device at a specified time interval.

=== Applying Property and Telemetry Fields in an IoT Context

When designing a model, a telemetry field is often used in models that represent IoT devices.

In this case, you will typically monitor incoming device data and take actions as the data arrives.

A property field is used most often when designing a model because properties provide you with backing storage and the ability to read and query the data fields.

=== Property and Telemetry Fields Example

Consider the following example:

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-components-azure-digital-twins-solution/media/m11-l02-telemetry-property-fields-twins-model-89781ba3.png[]


* IoT hub: IoT device with temperature sensor is connected to IoT hub.
* Azure Digital Twins model - telemetry field: Azure Function is used to deliver IoT telemetry data to Azure Digital Twins device twin (temp01).
* Azure Digital Twins model - property field: Monitor temp01 telemetry field events and capture “last received” value and “last received time” value. Store values in last_received and last_received_time property fields.
* Query model properties: Query as needed to extract most recently reported temperature and time.



== Digital Twins Definition Language

Models for Azure Digital Twins are defined using the Digital Twins Definition Language (DTDL), which is based on JSON-LD and is programming-language independent.


=== Implementation Specifics

For a DTDL model to be compatible with Azure Digital Twins, it must meet these requirements.

* All top-level DTDL elements in a model must be of type interface.
** Azure Digital Twins model APIs can receive JSON objects that represent either an interface or an array of interfaces.
**  As a result, no other DTDL element types are allowed at the top level.
* DTDL for Azure Digital Twins must not define any commands.
* Azure Digital Twins only allows a single level of component nesting.
** This requirement means that an interface that's being used as a component can't have any components itself.
* Interfaces can't be defined inline within other DTDL interfaces; they must be defined as separate top-level entities with their own IDs. 
** Then, when another interface wants to include that interface as a component or through inheritance, it can reference its ID.


=== Example Model Code

Twin type models can be written in any text editor.

Consider a solar system environment that contains models for planets, each with a name, a mass, and a temperature.

Each of the planets may also interact with moons that are their satellites, and the planets may contain craters.

In the DTDL code example below, the Planet model expresses connections to these other entities by referencing two external models—Moon and Crater.

These external models are also defined in the example code below, but are kept simple so as not to detract from the primary Planet example.

[source,json]
----
[
{
  "@id": "dtmi:com:contoso:Planet;1",
  "@type": "Interface",
  "@context": "dtmi:dtdl:context;2",
  "displayName": "Planet",
  "contents": [
    {
      "@type": "Property",
      "name": "name",
      "schema": "string"
    },
    {
      "@type": "Property",
      "name": "mass",
      "schema": "double"
    },
    {
      "@type": "Telemetry",
      "name": "Temperature",
      "schema": "double"
    },
    {
      "@type": "Relationship",
      "name": "satellites",
      "target": "dtmi:com:contoso:Moon;1"
    },
    {
      "@type": "Component",
      "name": "deepestCrater",
      "schema": "dtmi:com:contoso:Crater;1"
    }
  ]
},
{
  "@id": "dtmi:com:contoso:Crater;1",
  "@type": "Interface",
  "@context": "dtmi:dtdl:context;2"
},
{
  "@id": "dtmi:com:contoso:Moon;1",
  "@type": "Interface",
  "@context": "dtmi:dtdl:context;2"
}
]
----

The fields of the model are:

* *@id*
** An identifier for the model. Must be in the following format: dtmi:<domain>:<unique model identifier>;<model version number>
* *@type*
** Identifies the kind of information being described. For an interface, the type is Interface.
* *@context*
** Sets the context for the JSON document. Models should use the following: dtmi:dtdl:context;2
* *@displayName*
** (optional) Allows you to give the model a friendly name if desired.
* *contents*
** All remaining interface data is placed here, as an array of attribute definitions.
** Each attribute must provide an @type (Property, Telemetry, Command, Relationship, or Component) to identify the type of interface information it describes, and then a set of properties that define the actual attribute (for example, name and schema to define a Property).


=== Possible Schemas

As per DTDL, the schema for Property and Telemetry attributes can be of standard primitive types—integer, double, string, and Boolean—and other types such as DateTime and Duration.

In addition to primitive types, Property and Telemetry fields can have these complex types:

* Object
* Map
* Enum

Telemetry fields also support the Array type.


=== Model Inheritance

Sometimes, you may want to specialize a model further.

For example, it might be useful to have a generic model Room, and specialized variants ConferenceRoom and Gym.

To express specialization, DTDL supports inheritance: interfaces can inherit from one or more other interfaces.

The following example reimagines the Planet model from the earlier DTDL example as a subtype of a larger CelestialBody model.

The "parent" model is defined first, and then the "child" model builds on it by using the field “extends”.

[source,json]
----
[
{
    "@id": "dtmi:com:contoso:CelestialBody;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Celestial body",
    "contents": [
    {
        "@type": "Property",
        "name": "name",
        "schema": "string"
    },
    {
        "@type": "Property",
        "name": "mass",
        "schema": "double"
    },
    {
        "@type": "Telemetry",
        "name": "temperature",
        "schema": "double"
    }
    ]
},
{
    "@id": "dtmi:com:contoso:Planet;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Planet",
    "extends": "dtmi:com:contoso:CelestialBody;1",
    "contents": [
    {
        "@type": "Relationship",
        "name": "satellites",
        "target": "dtmi:com:contoso:Moon;1"
    },
    {
        "@type": "Component",
        "name": "deepestCrater",
        "schema": "dtmi:com:contoso:Crater;1"
    }
    ]
},
{
    "@id": "dtmi:com:contoso:Crater;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
}
]
----

In this example, CelestialBody contributes a name, a mass, and a temperature to Planet.

The extends section is an interface name, or an array of interface names (allowing the extending interface to inherit from multiple parent models if desired).

Once inheritance is applied, the extending interface exposes all properties from the entire inheritance chain.

The extending interface cannot change any of the definitions of the parent interfaces; it can only add to them.

It also cannot redefine a capability already defined in any of its parent interfaces

For example, if a parent interface defines a double property mass, the extending interface cannot contain a declaration of mass, even if it's also a double.


== Digital Twins and Graph Construction

In an Azure Digital Twins solution, the entities in your environment are represented by digital twins.

Each digital twin is an instance of one of your custom-defined digital models.

A digital twin can be connected to other digital twins via relationships to form a twin graph (a representation of your entire environment).

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-components-azure-digital-twins-solution/media/m11-l02-adt-graph-models-6a4c9f9b.png[]

The image below shows a simplified Contoso Cheese Factory Azure Digital Twins environment expressed as a twin graph.

The graph contains seven digital twin nodes connected by relationships. To the left of the twins graph are the corresponding models.


=== Digital Twins

Since the digital twins nodes that you create in your Azure Digital Twins solution are based on a model type, the first step in adding a digital twin to Azure Digital Twins is to upload a model type to your Azure Digital Twins service.

After creating and uploading a model, you can create an instance of the type; the digital twin.

For example, after creating a model of type Cheese Cave, you can create one or more digital twins that use this type (for example, a Cheese Cave digital twin called Cave_1, another called Cave_2, etc.).


=== Relationships: a graph of digital twins

Twins are connected into a twin graph by their relationships.

The relationships that a twin can have are defined as part of its model.

Twins are connected into a twin graph by their relationships.

The relationships that a twin can have are defined as part of its model.

For example, the model Cheese Factory might define a “Has Caves” relationship that targets twins of type Cheese Cave.

With this definition, Azure Digital Twins will allow you to create “Has Caves” relationships from any Cheese Factory twin to any Cheese Cave twin.

The result of this process is a set of nodes (the digital twins) connected via edges (their relationships) in a graph.


=== Visualization

While the primary way to interact with your Azure Digital Twins instance is through the APIs and SDKs, it can be helpful to see a visualization of the twins and graphs that you are creating in your instance.

Microsoft provides a sample application, the Azure Digital Twins explorer, that can be used to visualize the Azure Digital Twins graph and to edit the twins and models.

== Azure Digital Twins Solution Development Tools and Processes

The Azure Digital Twins service comes equipped with both control plane APIs and data plane APIs for managing your instance and its elements.

The Control plane APIs are Azure Resource Manager APIs used to manage your Azure Digital Twins instance as a whole, so they cover operations like creating or deleting your entire instance.

You will also use these APIs to create and delete endpoints.

The Data plane APIs are Azure Digital Twins APIs that are used for data management operations like managing models, twins, graph queries, and event routes.

== Azure Digital Twins Service Configuration

The initial setup for a new Azure Digital Twins instance consists of two parts:

* Create the Azure Digital Twins service instance.
* Set up user access permissions: Azure users will need to have the Azure Digital Twins Data Owner role on the Azure Digital Twins instance to be able to manage the Azure Digital Twins service and its data.

To set up user access permissions in Azure Digital Twins, you will need access to an Azure account that can assign user access permissions for the subscription that you are working in.

The account must have role assignments that include the following permissions:

* Create and manage Azure resources.
* Manage user access to Azure resources (including granting and delegating permissions).

With your Azure Digital Twins instance open in the Azure portal, you can use Access control (IAM), to configure role assignments.

.Source - Microsoft Learn
image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-create-instance-add-role-assignment-586d27e4.png[]

Common roles that meet this requirement are Owner, Account admin, or the combination of User Access Administrator and Contributor.

=== Configure endpoints and routes

In Azure Digital Twins, you can route event notifications to downstream services or connected compute resources.

This routing is done by first setting up endpoints that can receive the events.

You can then create event routes that specify which events generated by Azure Digital Twins are delivered to which endpoints.

You can manage Azure Digital Twins endpoints and routes in the Azure portal, with the Event Routes APIs, the SDKs, or the Azure Digital Twins CLI.

Azure Digital Twins supports the endpoint types listed below. The endpoint must exist before you can link to it.

* Event Grid
* Event Hubs
* Service Bus

[%header,cols="1,1"]
|===

|Endpoint
|Required resouces

|Event Grid endpoint
|Event Grid topic

|Event Hubs endpoint
|Event Hubs namespace Event Hubs (Optional) authorization rule for key-based authentication

|Service Bus endpoint
|Service Bus namespace Service Bus topic (Optional) authorization rule for key-based authentication

|===

Once you have created the endpoint resources, you can use them for an Azure Digital Twins endpoint.

To create your endpoint in the Azure portal, open your Azure Digital Twins blade, and then select Endpoints from the left-side menu.

.Source - Microsoft Learn
image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-create-endpoint-330a8fcf.png[]

In addition to the name and type of your endpoint, you will also need to specify your subscription and select the endpoint resource.

[NOTE]
====
For Event Hubs and Service Bus endpoints, you must also select an Authentication type.

You can use key-based authentication with a pre-created authorization rule, or identity-based authentication if you'll be using the endpoint with a managed identity for your Azure Digital Twins instance.
====

Once created, the endpoint is available as an endpoint inside of Azure Digital Twins, under the name you chose for the endpoint. You'll typically use that name as the target of an event route.

=== Create an Event Route

To actually send data from Azure Digital Twins to an endpoint, you'll need to define an event route.

These routes let developers wire up event flow, throughout the system and to downstream services.

An event route definition contains these elements:

* The route name you want to use.
* The name of the endpoint you want to use.
* A filter that defines which events are sent to the endpoint:
** To disable the route so that no events are sent, use a filter value of false.
** To enable a route that has no specific filtering, use a filter value of true.
** For details on any other type of filter, see the Filter events section below.

A single route can allow multiple notifications and event types to be selected.


To create an event route in the Azure portal, on the left-side menu of your Azure Digital Twins blade, select *Event routes*, and then, on the *Event routes* page, select + *Create an event route*.

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-create-event-route-103cae57.png[]

==== Filter Events

Routes have a filter field.

If the filter value on your route is false, no events will be sent to your endpoint.

After enabling the minimal filter of true, endpoints will receive various events from Azure Digital Twins:

* Telemetry fired by digital twins using the Azure Digital Twins service API.
* Twin property change notifications, fired on property changes for any twin in the Azure Digital Twins instance.
* Life-cycle events, fired when twins or relationships are created or deleted.

You can restrict the types of events being sent by defining a more specific filter.

To add an event filter while you are creating an event route, use the *Add an event route* filter section of the *Create an event route* page.

You can either select from some basic common filter options, or use the advanced filter options to write your own custom filters.

==== Basic Filters

To use the basic filters, expand the Event types option and select the checkboxes corresponding to the events you'd like to send to your endpoint.

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-create-event-route-103cae57.png[]

==== Advanced Filters

You can use the advanced filter option to write your own custom filters.

To create an event route with advanced filter options, toggle the switch for the Advanced editor to enable it. 

You can then write your own event filters in the Filter box:

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-create-event-route-filter-advanced-db13e6e2.png[]

Here are the supported route filters.

The detail in the Filter text schema column is the text that can be entered into the filter box.

[%header,cols="4*"]
|===

|Filter name
|Description
|Filter text schema
|Supported Values

|True / False
|Allows creating a route with no filtering, or disabling a route so no events are sent.
|`<true/false>`
|true = route is enabled with no filtering; false = route is disabled

|Type
|The type of event flowing through your digital twin instance.
|type = '<eventType>'
|Here are the possible event type values: Microsoft.DigitalTwins.Twin.Create Microsoft.DigitalTwins.Twin.Delete Microsoft.DigitalTwins.Twin.Update Microsoft.DigitalTwins.Relationship.Create Microsoft.DigitalTwins.Relationship.Update Microsoft.DigitalTwins.Relationship.Delete microsoft.iot.telemetry

|Source
|Name of Azure Digital Twins instance.
|source = `'<hostname>'`
|Here are the possible hostname values: For notifications: `<yourDigitalTwinInstance>.api.<yourRegion>.digitaltwins.azure.net` For telemetry: `<yourDigitalTwinInstance>.api.<yourRegion>.digitaltwins.azure.net/<twinId>`

|Subject
|A description of the event in the context of the event source above.
|subject = `'<subject>'`
|Here are the possible subject values: For notifications: The subject is <twinid> or a URI format for subjects, which are uniquely identified by multiple parts or IDs: <twinid>/relationships/<relationshipid> For telemetry: The subject is the component path (if the telemetry is emitted from a twin component), such as comp1.comp2. If the telemetry is not emitted from a component, then its subject field is empty.


|Data schema
|DTDL model ID.
|dataschema = `'<model-dtmi-ID>'`
|For telemetry: The data schema is the model ID of the twin or the component that emits the telemetry. For example, `dtmi:example:com:floor4;2` For notifications (create/delete): Data schema can be accessed in the notification body at `$body.$metadata.$model`. For notifications (update): Data schema can be accessed in the notification body at `$body.modelId`

|Content type
|Content type of data value.
|datacontenttype = `'<contentType>'`
|The content type is application/json

|Spec version
|The version of the event schema you are using.
|specversion = `'<version>'`
|The version must be 1.0. This indicates the CloudEvents schema version 1.0

|Notification body
|Reference any property in the data field of a notification.
|`$body.<property>`
|Any property in the data field can be referenced using `$body`

|===

The following data types are supported as values returned by references to the data above:

[%header,cols="2*"]
|===

|Data type
|Example

|String
|STARTS_WITH(`$body.$metadata.$model`, `'dtmi:example:com:floor'`) CONTAINS(subject, `'<twinID>'`)

|Integer
|`$body.errorCode > 200`

|Double
|`$body.temperature <= 5.5`

|Bool
|`$body.poweredOn = true`

|Null
|`$body.prop != null`

|===

The following operators are supported when defining route filters:

[%header,cols="3*"]
|===

|Family
|Operators
|Example

|Logical
|AND, OR, ( )
|`(type != 'microsoft.iot.telemetry' OR datacontenttype = 'application/json') OR (specversion != '1.0')`

|Comparison
|`<, <=, >, >=, =, !=`
|`$body.temperature <= 5.5`

|===

The following functions are supported when defining route filters:

[%header,cols="3*"]
|===

|Function
|Description
|Example

|STARTS_WITH(x,y)
|Returns true if the value x starts with the string y.
|`STARTS_WITH($body.$metadata.$model, 'dtmi:example:com:floor')`

|ENDS_WITH(x,y)
|Returns true if the value x ends with the string y.
|ENDS_WITH($body.$metadata.$model, 'floor;1')

|CONTAINS(x,y)
|Returns true if the value x contains the string y.
|CONTAINS(subject, '<twinID>')

|===

[NOTE]
====
When you implement or update a filter, the change may take a few minutes to be reflected in the data pipeline.
====

== Model Management
Model management operations include validation, upload, retrieval, update, and deletion.

You can manage the models within your Azure Digital Twins instance using the DigitalTwinModels APIs, the .NET (C#) SDK, or the Azure Digital Twins CLI extension.

=== Validating and Uploading Models

After creating a model, it's recommended that you validate your models offline before uploading them to your Azure Digital Twins instance.

==== Model Validation Tools

Microsoft provides the following tools that can be used to validate Azure Digital Twins models:

* *DTDL Validator:*
** The DTDL Validator is a language-agnostic sample app available for validating model documents to make sure the DTDL is correct before uploading it to your instance.
** It's located here: https://github.com/Azure-Samples/DTDL-Validator[DTDL Validator sample].
** The DTDL validator sample is built on a .NET DTDL parser library, which is available on NuGet as a client-side library: Microsoft.Azure.DigitalTwins.Parser.
** You can also use the library directly to design your own validation solution.
** When using the parser library, make sure to use a version that is compatible with the version that Azure Digital Twins is running.
* *DTDL Editor for Visual Studio Code*
** The DTDL extension for Visual Studio Code supports both model authoring and validation.
** The tool uses Intellisense to help you with the language syntax (including autocompletion) and syntax validation.
** The full documentation for the DTDL Editor for Visual Studio Code can be found here: DTDL - Visual Studio Marketplace.

==== Uploading Models to Azure Digital Twins

Once you're finished creating, extending, or selecting your models, you're ready to upload them to your Azure Digital Twins instance for use in your solution.

You can upload models using the following techniques:

* Azure Digital Twins REST APIs.
* Azure CLI commands.
* Azure Digital Twins SDKs and custom applications.

Microsoft also provides sample applications (based on the SDKs) that can be used to upload your models:

* *Azure Digital Twins-Explorer:*
** The Azure Digital Twins-Explorer is a sample application for the Azure Digital Twins service.
** It lets you connect to an Azure Digital Twins instance and, among other things, can help you to upload and explore your models.
** The Azure Digital Twins-explorer can be found here: https://learn.microsoft.com/en-us/samples/azure-samples/digital-twins-explorer/digital-twins-explorer/[Azure Digital Twins explorer]
* *Azure Digital Twins tools - UploadModels*
** If you have a large number of models to upload, or if the models have interdependencies that would make ordering individual uploads complicated, you may want to use the UploadModels tool.
** The tool accepts a list of models (including wildcard and glob support), validates the models using the digital twins parser, orders the models so that "root" models are uploaded first, and then uploads models in batches for fast uploading.
** The Azure Digital Twins UploadModels tool can be found here: https://github.com/Azure/opendigitaltwins-tools/tree/main/ADTTools#uploadmodels[Upload Models Tool].
** You can follow the instructions provided with the sample to configure and use this tool to upload models into your own instance.

=== Update and Version Models

Once a model is uploaded to your Azure Digital Twins instance, the entire model interface is immutable, which means there's no traditional "editing" of models.

Azure Digital Twins also doesn't allow reupload of the same model.

Instead, if you want to make changes to a model - such as updating displayName or description - the way to change the model is to upload a newer version of the model.

==== Model Versioning

To create a new version of an existing model, start with the DTDL of the original model. Update, add, or remove the fields you would like to change.

Next, mark the file as a newer version of the model by updating the ID field of the model.

The last section of the model ID, after the ";" character, represents the model number.

To indicate that the model version has been updated, increment the number at the end of the ID value.

The ID value can be any number greater than the current version number.

For example, if your previous model ID looked like this:

[source,json]
====
"@id": "dtmi:com:contoso:PatientRoom;1",
====

version 2 of this model might look like this:

[source,json]
====
"@id": "dtmi:com:contoso:PatientRoom;2",
====

Then, upload the new version of the model to your instance.

This version of the model will then be available in your instance to use for digital twins.

It does not overwrite earlier versions of the model, so multiple versions of the model will coexist in your instance until you remove them.

==== Impact on Twins

When you create a new twin, since the new model version and the old model version coexist, the new twin can use either the new version of the model or the older version.

Having an older version also means that uploading a new version of a model doesn't automatically affect existing twins.

The existing twins will remain instances of the old model version.

You can update these existing twins to the new model version by patching them.

[NOTE]
If you aren't familiar with JSON Patch, you can read more here: JsonPatch in ASP.NET Core web API

=== Remove Models

Models can also be removed from the service in one of two ways:

* *Decommisioning*
** Once a model is decommissioned, you can no longer use it to create new digital twins.
** Existing digital twins that already use this model aren't affected, so you can still update them with things like property changes and adding or deleting relationships.
* *Deletion*
** This will completely remove the model from the solution.
** Any twins that were using this model are no longer associated with any valid model, so they're treated as though they don't have a model at all.
** You can still read these twins, but won't be able to make any updates on them until they're reassigned to a different model.

Decommissioning and deletion are separate features and they don't impact each other, although they may be used together to remove a model gradually.

==== Decommissioning

Here's the C# code to decommission a model:

[souce, csharp]
====
// 'client' is a valid DigitalTwinsClient
await client.DecommissionModelAsync(dtmiOfPlanetInterface);
// Write some code that deletes or transitions digital twins
//...
====

A model's decommissioning status is included in the ModelData records returned by the model retrieval APIs.

==== Deletion

You can delete all models in your instance at once, or you can do it on an individual basis.

===== Before deletion: Deletion requirements

Generally, models can be deleted at any time.

The exception is models that other models depend on, either with an extends relationship or as a component.

For example, if a ConferenceRoom model extends a Room model, and has a ACUnit model as a component, you can't delete Room or ACUnit until ConferenceRoom removes those respective references.

You can solve the dependency issue by updating the dependent model to remove the dependencies, or by deleting the dependent model completely.

===== During deletion: Deletion process

Even if a model meets the requirements to delete it immediately, you may want to take steps to avoid unintended consequences (for the twins left behind).

Here are some steps that can help you manage the process:

. First, decommission the model.
. Wait a few minutes, to make sure the service has processed any last-minute twin creation requests sent before the decommission.
. Query twins by model to see all twins that are using the now-decommissioned model.
. Delete the twins if you no longer need them, or patch them to a new model if needed.
  * You can also choose to leave them alone, in which case they'll become twins without models once the model is deleted.
. Wait for another few minutes to make sure the changes have percolated through.
. Delete the model.

To delete a model, use this call:

[source, csharp]
====
// 'client' is a valid DigitalTwinsClient
await client.DeleteModelAsync(IDToDelete);
====

===== After deletion: Twins without models

Once a model is deleted, any digital twins that were using the model are now considered to be without a model.

Queries aren't able to give you a list of the twins in this state—although you can still query the twins by the deleted model to know what twins are affected.

Here's an overview of what you can and can't do with twins that don't have a model.

Things you can do:

* Query the twin.
* Read properties.
* Read outgoing relationships.
* Add and delete incoming relationships (as in, other twins can still form relationships to this twin). 
** The target in the relationship definition can still reflect the DTMI of the deleted model. A relationship with no defined target can also work here.
* Delete relationships.
* Delete the twin.

Things you cannot do:

* Edit outgoing relationships (as in, relationships from this twin to other twins).
* Edit properties.

===== After deletion: Reuploading a model

After a model has been deleted, you may decide later to upload a new model with the same ID as the one you deleted.

Here's what happens in that case.

* From the solution store's perspective, this is the same as uploading a new model. The service doesn't remember the old one was ever uploaded.
* If there are any remaining twins in the graph referencing the deleted model, they're no longer orphaned.
** The reused model ID is valid again with the new definition.
** However, if the new definition for the model is different than the model definition that was deleted, these twins may have properties and relationships that match the deleted definition and aren't valid with the new one.

Azure Digital Twins doesn't prevent this state, so be careful to patch twins appropriately in order to make sure they remain valid through the model definition switch.

== Azure Digital Twins API

https://learn.microsoft.com/en-us/rest/api/azure-digitaltwins/[Rest Api]

There are currently two Azure Digital Twins Data Plane Postman collections available for you to choose from:

* *Azure Digital Twins Postman Collection*
** https://github.com/microsoft/azure-digital-twins-postman-samples[postman_collection.json]
* *Azure Digital Twins Data Plane Swagger*
** https://github.com/Azure/azure-rest-api-specs/tree/master/specification/digitaltwins/data-plane/Microsoft.DigitalTwins[swagger file]

To get the bearer token use the get-access-token command of the cli:

[source, console]
====
az account get-access-token --resource 0b07f429-9f4b-4714-9392-cc5e8e80c8b0
====

== Azure Digital Twins CLI

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/6-get-started-with-azure-cli-for-azure-digital-twins[Microsoft Learn]

== Azure Digital Twins SDK

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/7-examine-azure-digital-twins-sdks[Microsoft Learn Samples]

== Manage Digital Twins in the Graph

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/8-manage-digital-twins-graph[Microsoft Learn Samples]

== Manage Digital Twin Relationships in the Graph

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/9-manage-digital-twin-relationships-graph[Microsoft Learn Samples]

== Azure Digital Twins Queries

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/9-manage-digital-twin-relationships-graph[Microsoft Learn Samples]

== Azure Functions for Azure Digital Twins

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/11-get-started-with-azure-functions-for-azure-digital-twins[Microsoft Learn Samples]

== Azure Digital Twins Event data

https://learn.microsoft.com/en-us/training/modules/examine-azure-digital-twins-solution-development-tools-processes/12-examine-azure-digital-twins-event-data[Microsoft Learn Samples]

== Data Ingress and Egress Processes

An Azure Digital Twins solution relies on external resources for data inputs and downstream services for analysis, storage, etc.

=== Data Ingress (upstream resources)

Data can be ingested into Azure Digital Twins through external compute resources such as an Azure Function.

==== Ingress Scenario

IoT Hub is a common source for data input to Azure Digital Twins.

Consider a scenario that includes the following items:

* A thermostat device in IoT Hub, with a known device ID
* A digital twin to represent the device, with a matching ID
* When IoT hub receives telemetry containing temperature values from the device, you need to set a temperature Property of the corresponding digital twin.

[NOTE]
====
This example uses a straightforward ID match between the device ID and a corresponding digital twin's ID, but it is possible to provide more sophisticated mappings from the device to its twin (such as with a mapping table).
====

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-telemetry-ingestion-iot-hub-64bbcc4b.png[]

In this case, an Azure Function receives the data from IoT hub's built-in Event Grid endpoint and uses the Azure Digital Twins APIs to set properties on a digital twin contained within an Azure Digital Twins instance.

The Azure Function could also pass temperature telemetry to a Telemetry field of the digital twin.

=== Data Egress

To provide data to downstream resources, Azure Digital Twins uses digital twin change notification events as a trigger to route data to an Azure Digital Twins endpoint where the information can be accessed and used to accomplish a desired action.

==== Egress scenario (in-service updates)

Although Azure Digital Twins relationships connect digital twins as parent and child, properties of a child are not automatically passed up to a parent in the case when a corresponding property is defined.

Consider a scenario that includes the following items:

* An Azure Digital Twins environment contains Room digital twins (such as Room_01, Room_02, etc.) and Thermostat digital twins (such as thermo_0001).
* The Room digital twins have a rel_has_thermostat relationship and each Room has a Thermostat (establishing a Parent-Child relationship).
* The Thermostat digital twins have Property and Telemetry fields for temperature data that is coming from IoT hub.
* Room digital twins have a Property for currentTemp.
* When a Thermostat digital twin Property changes, you need to update the currentTemp Property of the Room digital twin (the Room digital twin that is the parent of that Thermostat digital twin)

image::hhttps://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-service-update-process-d64af8fb.png[]

Whenever a Digital Twin Change Notification event occurs for a Thermostat digital twin, the following process is invoked:

* Data is routed to an Event Grid endpoint.
* The Event Grid uses an Event Subscription to specify an Azure Function "listener“, creates a new event message using the Azure Digital Twins notification, and uses the new event to pass the required information to the function.
* The Azure Function extracts the event message data and uses it to obtain the twin's ID and Relationship information, uses the Relationship to find the parent Room digital twin, and then updates the currentTemp Property by applying a patch.

==== Egress Scenario (downstream services)

Azure Digital Twins feeds data to downstream services by using event notifications and routing.

Consider a scenario that includes the following items:

* An Azure Digital Twins environment contains Room digital twins (such as Room_01, Room_02, etc.) and Thermostat digital twins (such as thermo_0001).
* The Room digital twins have a rel_has_thermostat relationship and each Room has a Thermostat.
* Room digital twins also have a Property for currentTemp.
* The Thermostat digital twins have Property and Telemetry fields for temperature data coming from IoT hub.
* You need to analyze the temperature Telemetry data using Azure Time Series Insights.

image::https://learn.microsoft.com/en-us/training/wwl-azure/examine-azure-digital-twins-solution-development-tools-processes/media/m11-l03-adt-downstream-tsi-3f1a5ca4.png[]

Whenever a Digital Twin Telemetry Messages event notification occurs for a Thermostat digital twin, the following process is invoked:

. Data is routed to an Event Hubs endpoint.
. The Event Hubs processes events and triggers an Azure Function.
. The Azure Function creates a new event for TSI, adds a partition key, and then publishes the new event to another Event Hubs.
. Azure TSI (subscribed to events from the second Event Hubs) processes the incoming events to perform the required data analysis.